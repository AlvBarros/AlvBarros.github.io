<html>
    <head>
        <!-- LEAFLET -->
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.5.1/dist/leaflet.css"
        integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
        crossorigin=""/>
        <script src="https://unpkg.com/leaflet@1.5.1/dist/leaflet.js"
        integrity="sha512-GffPMF3RvMeYyc1LWMHtK8EbPv0iNZ8/oTtHPx9/cc2ILxQ+u905qIwdpULaqDkyBKgOaB57QTMg7ztg8Jm2Og=="
        crossorigin=""></script>
        <!-- </> -->

        <!-- MAP BOX -->
        <script src='https://api.mapbox.com/mapbox-gl-js/v1.4.1/mapbox-gl.js'></script>
        <link href='https://api.mapbox.com/mapbox-gl-js/v1.4.1/mapbox-gl.css' rel='stylesheet' />
        <!-- </> -->
        <style>
        #mapid {
            height: 600px;
            width: 800px;
            margin: auto;
            display: block;
        }
        </style>

		<script src='https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.5/leaflet-routing-machine.js'></script>
		<link href='https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.5/leaflet-routing-machine.css' rel='stylesheet' />

		<script src='https://cdnjs.cloudflare.com/ajax/libs/perliedman-leaflet-control-geocoder/1.5.5/Control.Geocoder.min.js'></script>
		<link href='https://cdnjs.cloudflare.com/ajax/libs/perliedman-leaflet-control-geocoder/1.5.5/Control.Geocoder.min.css' rel='stylesheet' />
    </head>
    <body>
        <div id="mapid"></div>
		<input type="button" id="calcular" value="Calcular"/>
    </body>
    <script>
        var locations = [];
		var markers = [];

		navigator.geolocation.getCurrentPosition((pos) => {
			var mymap = L.map('mapid').setView([pos.coords.latitude, pos.coords.longitude], 13);

			mapboxgl.accessToken = 'pk.eyJ1IjoiYWx2YiIsImEiOiJjanRkazRlNW4wZHZwNDZwN3FmNHJ2NDQ3In0.FiOFxgQ3B-X6QFwUAEYJbw';

			L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
				attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>',
				maxZoom: 18,
				id: 'mapbox.streets',
				accessToken: mapboxgl.accessToken
			}).addTo(mymap);

			const popup = L.popup();
			const marker = L.marker;
			function onMapClick(e) {
				if (locations.filter((coords) => {
					coords[0] == e.latlng.lat && coords[1] == e.latlng.lng
					var diffLat = (e.latlng.lat - coords[0]);
					var diffLng = (e.latlng.lng - coords[1]);
					if (diffLat < 0) diffLat = diffLat * -1;
					if (diffLng < 0) diffLng = diffLng * -1;
					return diffLat < 0.001 && diffLng < 0.001;
				}).length == 0) {
					locations.push([e.latlng.lat, e.latlng.lng]);
					var layer = L.marker([e.latlng.lat, e.latlng.lng])
					markers.push(layer);
					layer.addTo(mymap);

					layer.on('click', () => {
						layer.remove();
						locations = locations.filter((loc) => {
							return loc[0] != e.latlng.lat &&
								loc[1] != e.latlng.lng;
						});
					});
					console.log(`${locations.length} added.`);
				}
			}

			mymap.on("click", onMapClick);
			document.getElementById("calcular").addEventListener("click", () => {
				new Promise((resolve) => {
					let request = new XMLHttpRequest();
					request.open('POST', "https://api.openrouteservice.org/v2/matrix/driving-car");
					request.setRequestHeader('Accept', 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8');
					request.setRequestHeader('Content-Type', 'application/json');
					request.setRequestHeader('Authorization', '5b3ce3597851110001cf624883561aed03e04c899ca39553fd0001e3');
					request.onreadystatechange = function () {
						if (this.readyState === 4) {
							// console.log('Status:', this.status);
							// console.log('Headers:', this.getAllResponseHeaders());
							// console.log('Body:', this.responseText);
							resolve(JSON.parse(this.responseText));
						}
					};
					let body = JSON.stringify({
						locations: locations.map((loc) => {
							return [Number(parseFloat(loc[1]).toFixed(5)), Number(parseFloat(loc[0]).toFixed(5))];
						})
					});
					request.send(body);
				}, (reject) => {
					console.log('ERROR', reject);
					reject();
				})
				.then((result) => {
					var dis = result.durations;
					console.log(dis)

					function checkExist(array, item){
						for(var i = 0; i<array.length; i++){
							if(array[i] == item){
							return true;
							}
						}
						return false;
					}
					function calculateCurrentValue(){
						bestValue = 0;
						for(var i = 0; i < best.length - 1; i++){
							// bestValue += distance(points[best[i]], points[best[i+1]]);
							bestValue += dis[best[i]][best[i+1]];
						}
						// bestValue += distance(points[best[best.length-1]], points[best[0]])
						bestValue += dis[best[best.length-1]][best[best[0]]];
						return bestValue;
					}

					Array.prototype.clone = function() { return this.slice(0); }

					var sourceCity;
					var initialRoute, optimumRoute;
					var nodes;
					var routeCost;
					var optimumCost;
					var bnbFinish = false;
					var bnbRunning = false;
					function BNBInitialize(){
							sourceCity = 0
							initialRoute  = [0];
							optimumRoute = [];
							nodes = 1;
							routeCost = 0;
							optimumCost = Number.MAX_VALUE;
							bnbFinish = false;
							best = [];
					}
					function BNBCompute(){
						if(bnbFinish){
							return;
						}
						if(bnbRunning){
							return;
						}
						var n = locations.length;
						if(n > 15){
							alert("Too many point to calculate for Branch and Bound algorithm");
							running = false;
							bnbRunning = false;
							bnbFinish = true;
							return;
						}
						BNBSearch(sourceCity, initialRoute);
						best = optimumRoute.clone();
						calculateCurrentValue();
						bnbRunning = false;
						bnbFinish = true;
						console.log(best);

						let  router = L.Routing.osrmv1();
						let waypoints = [];
						let line;

						best.slice(0, best.length-1).map((b) => {
							let loc = locations[b];
							waypoints.push({latLng: L.latLng(loc[0], loc[1])});
						});

						router.route(waypoints, (err, routes) => {
							if (line) {
								mymap.removeLayer(line);
							}
							if (err) {
								alert(err);
							} else {
								line = L.Routing.line(routes[0]).addTo(mymap);
							}

						});
					}
					function BNBSearch(from, followedRoute){
							if (followedRoute.length == locations.length) {
									followedRoute.push(sourceCity);
									nodes++;
									routeCost += dis[from][sourceCity];
									if (routeCost < optimumCost) {
											optimumCost = routeCost;
											optimumRoute = followedRoute.clone();
									}
									routeCost -= dis[from][sourceCity];
							}
							else {
								for (var to=0; to<locations.length; to++){
									if (!checkExist(followedRoute,to)) {
										routeCost += dis[from][to];
										if (routeCost < optimumCost) {
											var increasedRoute = followedRoute.clone();
											increasedRoute.push(to);
											nodes++;
											BNBSearch(to, increasedRoute);
										}
										routeCost -= dis[from][to];
									}
								}
							}
					}
					BNBInitialize();
					BNBCompute();
				}, (reject) => {});
			});
		});
    </script>
</html>